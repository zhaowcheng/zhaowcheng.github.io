---
title: paramiko下载整个目录
categories: 
 - Python
tags:
 - paramiko
 - sftp
---

使用paramiko.SFTPClient，参考os.walk实现一个下载整个目录方法。

# paramiko简介

paramiko是一个对SSH协议进行实现的Python库，官方介绍如下：
>Paramiko is a Python (2.7, 3.4+) implementation of the SSHv2 protocol [[1]](http://www.paramiko.org/#id2), providing both client and server functionality. While it leverages a Python C extension for low level cryptography ([Cryptography](https://cryptography.io/)), Paramiko itself is a pure Python interface around SSH networking concepts.

# os.walk简介
os.walk是Python的os模块里的一个遍历目录树的方法，源码如下(Python 2.7.10)：
```python
def walk(top, topdown=True, onerror=None, followlinks=False):
    """Directory tree generator.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), yields a 3-tuple

        dirpath, dirnames, filenames

    dirpath is a string, the path to the directory.  dirnames is a list of
    the names of the subdirectories in dirpath (excluding '.' and '..').
    filenames is a list of the names of the non-directory files in dirpath.
    Note that the names in the lists are just names, with no path components.
    To get a full path (which begins with top) to a file or directory in
    dirpath, do os.path.join(dirpath, name).

    If optional arg 'topdown' is true or not specified, the triple for a
    directory is generated before the triples for any of its subdirectories
    (directories are generated top down).  If topdown is false, the triple
    for a directory is generated after the triples for all of its
    subdirectories (directories are generated bottom up).

    When topdown is true, the caller can modify the dirnames list in-place
    (e.g., via del or slice assignment), and walk will only recurse into the
    subdirectories whose names remain in dirnames; this can be used to prune the
    search, or to impose a specific order of visiting.  Modifying dirnames when
    topdown is false is ineffective, since the directories in dirnames have
    already been generated by the time dirnames itself is generated. No matter
    the value of topdown, the list of subdirectories is retrieved before the
    tuples for the directory and its subdirectories are generated.

    By default errors from the os.listdir() call are ignored.  If
    optional arg 'onerror' is specified, it should be a function; it
    will be called with one argument, an os.error instance.  It can
    report the error to continue with the walk, or raise the exception
    to abort the walk.  Note that the filename is available as the
    filename attribute of the exception object.

    By default, os.walk does not follow symbolic links to subdirectories on
    systems that support them.  In order to get this functionality, set the
    optional argument 'followlinks' to true.

    Caution:  if you pass a relative pathname for top, don't change the
    current working directory between resumptions of walk.  walk never
    changes the current directory, and assumes that the client doesn't
    either.

    Example:

    import os
    from os.path import join, getsize
    for root, dirs, files in os.walk('python/Lib/email'):
        print root, "consumes",
        print sum([getsize(join(root, name)) for name in files]),
        print "bytes in", len(files), "non-directory files"
        if 'CVS' in dirs:
            dirs.remove('CVS')  # don't visit CVS directories

    """

    islink, join, isdir = path.islink, path.join, path.isdir

    # We may not have read permission for top, in which case we can't
    # get a list of the files the directory contains.  os.path.walk
    # always suppressed the exception then, rather than blow up for a
    # minor reason when (say) a thousand readable directories are still
    # left to visit.  That logic is copied here.
    try:
        # Note that listdir and error are globals in this module due
        # to earlier import-*.
        names = listdir(top)
    except error, err:
        if onerror is not None:
            onerror(err)
        return

    dirs, nondirs = [], []
    for name in names:
        if isdir(join(top, name)):
            dirs.append(name)
        else:
            nondirs.append(name)

    if topdown:
        yield top, dirs, nondirs
    for name in dirs:
        new_path = join(top, name)
        if followlinks or not islink(new_path):
            for x in walk(new_path, topdown, onerror, followlinks):
                yield x
    if not topdown:
        yield top, dirs, nondirs
```

# sftp.walk实现

参考os.walk实现一个sftp.walk方法，代码片段如下(注：self.conn是一个paramiko.SFTPClient实例)：
```python
def walk(self, top):
        """
        Recursively traverse all subdirectories and files.
        Similar to os.walk.

        :param top: The path of directory to be walked.
        :return: root, dirs, files
        """

        dirs, files =  [], []
        for a in self.conn.listdir_attr(top):
            if stat.S_ISDIR(a.st_mode):
                dirs.append(a.filename)
            else:
                files.append(a.filename)
        yield top, dirs, files

        for d in dirs:
            for w in self.walk(top + '/' + d):
                yield w
```

# sftp.get_dir实现

 现在把sftp.walk稍微改一下，实现一个sftp.get_dir方法：
```python
def get_dir(self, remote, local):
        """
        Recursively download all directories and files.

        :param remote: Remote dir that to be got.
        :param local: Local dir that to save remote files.
        """

        for a in self.conn.listdir_attr(remote):
            r = remote + '/' + a.filename
            l = os.path.join(local, a.filename)
            if stat.S_ISDIR(a.st_mode):
                if not os.path.exists(l):
                    os.makedirs(l)
                self.get_dir(r, l)
            else:
                self.conn.get(r, l)
```

# sftp完整代码

```python
# coding: utf-8
# author: WanCheng <zhaowcheng@163.com>

import paramiko
import stat
import os


class Sftp(object):
    """
    SFTP Client.
    """
    def __init__(self, host, port=22):
        """
        Constructor.

        :param host: ip or hostname.
        :param port: ssh port.
        """

        self.host = host
        self.port = port
        self.conn = None

    def connect(self, username, password):
        """
        SFTP connect to remote host.

        :param username: Login username.
        :param password: Login password.
        """

        t = paramiko.Transport((self.host, self.port))
        t.connect(username=username, password=password)
        self.conn = paramiko.SFTPClient.from_transport(t)

    def walk(self, top):
        """
        Recursively traverse all subdirectories and files.
        Similar to os.walk.

        :param top: The path of directory to be walked.
        :return: root, dirs, files
        """

        dirs, files =  [], []
        for a in self.conn.listdir_attr(top):
            if stat.S_ISDIR(a.st_mode):
                dirs.append(a.filename)
            else:
                files.append(a.filename)
        yield top, dirs, files

        for d in dirs:
            for w in self.walk(top + '/' + d):
                yield w

    def get_dir(self, remote, local):
        """
        Recursively download all directories and files.

        :param remote: Remote dir that to be got.
        :param local: Local dir that to save remote files.
        """

        for a in self.conn.listdir_attr(remote):
            r = remote + '/' + a.filename
            l = os.path.join(local, a.filename)
            if stat.S_ISDIR(a.st_mode):
                if not os.path.exists(l):
                    os.makedirs(l)
                self.get_dir(r, l)
            else:
                self.conn.get(r, l)
```

# 使用示例

现在有一个远端Linux机器上存在如下结构的一个目录remote_sftp：
```shell
[/] # find remote_sftp -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g' 
remote_sftp
|____file2
|____file1
|____subdir2
| |____file2_2
| |____file2_1
| |____subdir2_2
| | |____file2_2_2
| | |____file2_2_1
| |____subdir2_1
| | |____file2_1_2
| | |____file2_1_1
|____subdir1
| |____file1_2
| |____file1_1
| |____subdir1_2
| | |____file1_2_2
| | |____file1_2_1
| |____subdir1_1
| | |____file1_1_2
| | |____file1_1_1
```

现在使用刚才实现的sftp.walk浏览远端的remote_sftp目录
```python
s = Sftp('192.168.1.12')
s.connect('username', 'password')
for parent, dirs, files in s.walk('/remote_sftp'):
    print 'parent=%s' % parent
    print 'dirs=%s' % dirs
    print 'files=%s' % files
    print '-' * 50

# output
parent=/remote_sftp
dirs=[u'subdir2', u'subdir1']
files=[u'file2', u'file1']
--------------------------------------------------
parent=/remote_sftp/subdir2
dirs=[u'subdir2_2', u'subdir2_1']
files=[u'file2_2', u'file2_1']
--------------------------------------------------
parent=/remote_sftp/subdir2/subdir2_2
dirs=[]
files=[u'file2_2_2', u'file2_2_1']
--------------------------------------------------
parent=/remote_sftp/subdir2/subdir2_1
dirs=[]
files=[u'file2_1_2', u'file2_1_1']
--------------------------------------------------
parent=/remote_sftp/subdir1
dirs=[u'subdir1_2', u'subdir1_1']
files=[u'file1_2', u'file1_1']
--------------------------------------------------
parent=/remote_sftp/subdir1/subdir1_2
dirs=[]
files=[u'file1_2_2', u'file1_2_1']
--------------------------------------------------
parent=/remote_sftp/subdir1/subdir1_1
dirs=[]
files=[u'file1_1_2', u'file1_1_1']
--------------------------------------------------
```

再使用sftp.get_dir下载远端的remote_sftp目录
```python
s = Sftp('192.168.1.12')
s.connect('username', 'password')
s.get_dir('/remote_sftp', '/Users/WANCHENG/local_sftp')
```

执行后查看本地local_sftp目录结构如下：
```shell
Mac:~ WANCHENG$ find local_sftp -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'
local_sftp
|____file1
|____file2
|____subdir1
| |____file1_1
| |____file1_2
| |____subdir1_1
| | |____file1_1_1
| | |____file1_1_2
| |____subdir1_2
| | |____file1_2_1
| | |____file1_2_2
|____subdir2
| |____file2_1
| |____file2_2
| |____subdir2_1
| | |____file2_1_1
| | |____file2_1_2
| |____subdir2_2
| | |____file2_2_1
| | |____file2_2_2
```

